---
tags:
  - 计算机
  - 教程
  - AI
source: https://www.bilibili.com/video/BV1FPCzYdEeH
title: 全栈开发笔记
toc: "true"
---

>说明
>本文写于2025年春，但是具体是什么时候，忘了。故暂定时间为3月10日。

> [!info]+ 本篇笔记的完成方式
> 本笔记（将会）由 kimi，或者 deepseek，或者 chatgpt，或者 grok 赞助记出！
> 笔记方法：
> 我首先列出 key words，再拿出一段教程中的代码。
> 然后自己写一小段笔记。
> 然后拿着这个风格让 AI 指导一下有没有改进之处。
> 定好终稿后，让 AI 总结一下这个稿子的特点。
> 最后，把其它段落 key words, code, 修改后的笔记，还有稿子的特点，一并输入 AI，并以输出作为最终笔记内容。

> [!hint]- AI Prompts
> 
> 你好，现在请由你来扮演我的学习搭子，帮我完成我的笔记。
> 我会先给你一小段我写的笔记，让你学习并且总结我的风格，之后你写的笔记应当遵循这种风格。请注意这段笔记就是"本章目录"下的一个小节，并且它涵盖了 key words list 中的几个 key words.
> 然后，我会给你本章目录和 key words list，按照这两个东西的顺序，来记录关于这些 key words 的笔记吧。
> 同时，我会给你一个程序，你可以用这个程序中的代码片段来举例子，让笔记更加直观清晰。
>  章节：
>  本章目录：
>  
>  key words:
>  
>  程序：
>  
>  笔记样例：
>
> >[!example]
> >### 事件监听 ||  `@[movement]=[function name]`
> >事件监听的作用是：当用户对页面上的某个东西（比如按钮）做了某个动作（比如点击）时，就会自动执行一段代码（比如一个函数）。简单来说，就是“用户做了什么动作，页面就做出什么反应”。
> >在 Vue.js 中，事件监听是通过在标签上加一个 `@` 符号来实现的。
> >具体样例如下：
> >```vue
> ><div @click="add" class="button">Click me to call function add.</div>
> >```
> >*注：上面的 `button` 是我们假想出来的一个类，假设这个 `button` 类已经在 `<style>` 里面写好了，它就是一个按钮样式。*
> >**运行效果：**
> >当用户点击这个按钮时，页面就会调用 `add` 函数。
> >如果 `add` 函数的作用是增加一个数字，那么每次点击按钮，数字就会增加。
> >
> >除了点击事件 `@click`，还有其他事件可以用来监听用户的操作：
> >- **`@mouseenter`**：当鼠标移入按钮时触发。
> >- **`@mouseleave`**：当鼠标移出按钮时触发。
>
>以上样例中，用到目录（并非本目录）中的“事件监听”和 key words list（并非本 list） 中的@click，@mouseenter，@mouseleave。样例的特点是：语言简洁直白、举一反三能力强、注释清晰实用、结构循序渐进、注重实用体现。

# *HTML+CSS*

> [!info] powered by Kimi

> [!summary]- 提示词填充
> 章节：HTML+CSS
> 本章目录：HTML 和 CSS 的基础格式，创建类，盒子（div），输入-选择框，图片，CSS 样式。
> 
> key words:
> 盒子（div）
> style
> style class
> .style_eg{}
> 
> 
> 
> width
> height
> background-color
> border
> margin
> border-radius
> 圆角
> 周围阴影
> 字体颜色
> 字体大小
> 文字对齐
> 
> 盒子的排列方式（横着，竖着）
> 
> 创建图片 img
> （图片）大小
> 边框
> 位置
> 圆角
> 
> 创建输入框
> 
> 背景颜色
> 颜色渐变

### 盒子（div）与样式

**盒子（div）** 是HTML中非常重要的一个元素，它用于创建一个容器，可以用来包裹其他元素，方便布局和样式控制。在CSS中，可以通过 `class` 属性为盒子指定样式。

在提供的代码中，`.todo-app` 就是一个典型的盒子，它包裹了整个 Todo 应用的内容。通过 CSS，我们为它设置了宽度、高度、背景颜色、圆角等样式：

```html
<div class="todo-app">
    <!-- 内容 -->
</div>
```

```css
.todo-app {
    width: 98%;               /* 宽度 */
    height: 500px;            /* 高度 */
    background-color: #ffffff;/* 背景颜色 */
    border-radius: 5px;       /* 圆角 */
    margin-top: 40px;          /* 顶部外边距 */
    padding-top: 30px;         /* 内边距 */
    margin-left: 1%;           /* 左侧外边距 */
}
```

### 样式（style）与类（style class）

在HTML中，可以通过 `style` 属性直接为元素添加内联样式，或者通过 `class` 属性引用 CSS 类来设置样式。`class` 是更推荐的方式，因为它更灵活，便于复用。

例如，`.todo-button` 是一个按钮类，它设置了宽度、高度、背景颜色、圆角等样式：

```html
<div class="todo-button">add todo</div>
```

```css
.todo-button {
    width: 100px;                       /* 宽度 */
    height: 54px;                       /* 高度 */
    border-radius: 0 20px 20px 0;       /* 圆角 */
    background: linear-gradient(to right, rgb(113, 65, 168), rgba(44, 114, 251, 1)); /* 背景颜色渐变 */
    color: #ffffff;                     /* 字体颜色 */
    cursor: pointer;                    /* 鼠标悬停时显示为指针 */
    user-select: none;                  /* 防止文字被选中 */
}
```

### 样式属性

#### 宽度（width）和高度（height）

`width` 和 `height` 用于设置元素的宽度和高度。在 `.todo-button` 中，宽度设置为 `100px`，高度设置为 `54px`，这样按钮的大小就固定了。

#### 背景颜色（background-color）和颜色渐变

**背景颜色**`background-color` 用于设置元素的背景颜色，而 `background` 属性可以实现更复杂的背景效果，比如颜色渐变。在 `.todo-button` 中，使用了颜色渐变：

```css
background: linear-gradient(to right, rgb(113, 65, 168), rgba(44, 114, 251, 1));
```

这表示背景颜色从左到右从 `rgb(113, 65, 168)` 渐变到 `rgba(44, 114, 251, 1)`。

#### 边框（border）和圆角（border-radius）

**边框**`border` 是一个复合属性，用于设置元素的边框样式，包括边框的宽度、样式和颜色。它可以通过简写形式一次性设置这三个属性，也可以分开单独设置。

- **简写形式**：`border: <宽度> <样式> <颜色>;`
  - 例如：`border: 2px solid #000;` 表示边框宽度为 2 像素，样式为实线，颜色为黑色。

- **单独设置**：
  - `border-width`：设置边框宽度，单位通常是像素（px）。
  - `border-style`：设置边框样式，常见的值有 `solid`（实线）、`dashed`（虚线）、`dotted`（点线）、`double`（双线）等。
  - `border-color`：设置边框颜色，可以使用颜色名称（如 `red`）、十六进制颜色代码（如 `#ff0000`）或 RGB/RGBA 值。


**圆角**`border-radius` 用于设置元素边框的圆角效果，使边框的角从直角变为圆角。它的参数可以有 1 到 4 个值，分别对应不同的角，参数的个数不同，效果也会有所不同。

- **1 个值**：所有角的圆角半径相同。
- 2 个，3 个值省略了，不常用
- **4 个值**：分别对应左上角、右上角、右下角和左下角的圆角半径。
  - 例如：`border-radius: 10px 20px 30px 40px;` 表示左上角的圆角半径为 10 像素，右上角为 20 像素，右下角为 30 像素，左下角为 40 像素。

这种设置通常用于创建类似按钮的样式，使按钮的一侧是直角，另一侧是圆角，增强视觉效果。

---

#### 外边距（margin）和内边距（padding）

**外边距**  `margin`是元素与其他元素之间的间距，用于控制元素之间的距离。它也可以通过简写形式一次性设置上下左右四个方向的外边距，也可以单独设置。

- **简写形式**：`margin: <上> <右> <下> <左>;`
  - 例如：`margin: 10px 20px 30px 40px;` 表示上边距为 10 像素，右边距为 20 像素，下边距为 30 像素，左边距为 40 像素。

如果参数个数不同：

- **`margin`** 是元素与其他元素之间的间距，用于控制元素之间的距离。参数个数不同，设置的范围也不同：
  - 1 个值：上下左右都相同。
  - 2 个值：上下相同，左右相同。
  - 3 个值：上、左右、下分别设置。
  - 4 个值：分别设置上、右、下、左。

在 `.todo-app` 中，`margin-top` 设置为 `40px`，表示该元素顶部与其他元素的间距为 40像素。

**内边距** `padding` 是元素内部的间距，用于控制元素内容与边框之间的距离。它与 `margin` 类似，也可以通过简写形式一次性设置上下左右四个方向的内边距，也可以单独设置。

- **简写形式**：`padding: <上> <右> <下> <左>;`
  - 例如：`padding: 10px 20px 30px 40px;` 表示上内边距为 10 像素，右内边距为 20 像素，下内边距为 30 像素，左内边距为 40 像素。

如果参数个数不同：

- **1 个值**：所有方向的内边距相同。
  - 例如：`padding: 10px;` 表示上下左右的内边距都是 10 像素。

- **2 个值**：第一个值用于上下内边距，第二个值用于左右内边距。
  - 例如：`padding: 10px 20px;` 表示上下内边距为 10 像素，左右内边距为 20 像素。

- **3 个值**：第一个值用于上内边距，第二个值用于左右内边距，第三个值用于下内边距。
  - 例如：`padding: 10px 20px 30px;` 表示上内边距为 10 像素，左右内边距为 20 像素，下内边距为 30 像素。

在 `.todo-app` 中，`padding-top` 设置为 `30px`，表示该元素内容与顶部边框之间的距离为 30像素。

#### 字体颜色（color）和字体大小（font-size）

`color` 用于设置文字颜色，`font-size` 用于设置文字大小。在 `.title` 中，字体大小设置为 `30px`，字体颜色默认为黑色。

```css
.title {
    font-size: 30px;          /* 字体大小 */
    font-weight: 700;         /* 字体加粗 */
    text-align: center;       /* 文字居中 */
    margin-top: 30px;         /* 顶部外边距 */
}
```

#### 文字对齐（text-align）

`text-align` 用于设置文字的对齐方式，比如居中、左对齐、右对齐。在 `.title` 中，文字是居中的。

### 盒子的排列方式

在CSS中，可以通过 `display` 属性设置盒子的排列方式。例如，`.todo-from` 和 `.item` 都使用了 `flex` 布局，使子元素可以水平或垂直排列。

```css
.todo-from {
    display: flex;            /* 水平排列 */
    margin-left: 30px;
    margin-top: 20px;
}

.item {
    display: flex;            /* 水平排列 */
    margin: 8px auto;
    width: 80%;
    height: 50px;
    padding: 16px;
    align-items: center;      /* 垂直居中 */
    justify-content: space-between; /* 子元素两端对齐 */
}
```

### 创建图片（img）

在HTML中，可以通过 `<img>` 标签插入图片，并通过 CSS 设置图片的样式。

```html
<img src="example.jpg" alt="example" class="example-img">
```

```css
.example-img {
    width: 100px;             /* 图片宽度 */
    height: 100px;            /* 图片高度 */
    border: 1px solid #dfe1e5;/* 图片边框 */
    border-radius: 10px;      /* 图片圆角 */
    box-shadow: rgba(149,157,165,0.2) 0px 8px 20px; /* 图片阴影 */
}
```

### 创建输入框（input）

在HTML中，可以通过 `<input>` 标签创建输入框，并通过 CSS 设置其样式。

```html
<input type="text" class="todo-input" placeholder="add a todo">
```

```css
.todo-input {
    margin-bottom: 30px;
    padding-left: 15px;
    border: 1px solid #dfe1e5;
    outline: none;            /* 去掉默认边框 */
    width: 60%;
    height: 50px;
    border-radius: 20px 0 0 20px;
}
```

总结：本章主要介绍了 HTML 和 CSS 的基础知识，包括盒子（div）的使用、样式设置（如宽度、高度、背景颜色、圆角等），以及如何通过 CSS 实现盒子的排列和布局。同时，还涉及了如何创建图片和输入框，并为它们设置样式。

# *JavaScript*

> [!info] powered by ChatGPT

> [!summary]- 提示词填充
> 章节：JavaScript
> 章节目录：基础操作（包含 let, if-else, for）、嵌入 html
> 
> 
> key words:
> let
> console.log
> let obj = {
> xx:xx,
> }
> let list = \[]
> 
> <div>{{arg}} </div>
> 写在 script 中
> if-else
> for

### 1. 基础操作：`let`、`if-else`、`for`

#### 1.1 `let`

`let` 用来声明变量，具有块级作用域。可以用于声明基本类型、对象和数组。

示例：

```javascript
let num = 10; // 声明一个数字变量
let name = 'John'; // 声明一个字符串变量

let user = { // 声明一个对象
  name: 'Alice',
  age: 25
};
console.log(user.name); // 输出 'Alice'
console.log(user.age);  // 输出 25

let numbers = [1, 2, 3, 4, 5]; // 声明一个数组
console.log(numbers[0]); // 输出 1
```

#### 1.2 `console.log`

`console.log` 用于在浏览器的控制台打印输出信息。常用来调试代码，查看变量值。

示例：

```javascript
let message = 'Hello, world!';
console.log(message); // 控制台输出 'Hello, world!'
```

#### 1.3 `if-else`

`if-else` 用于条件判断，根据条件的真假决定执行不同的代码块。

示例：

```javascript
let age = 18;
if (age >= 18) {
  console.log('Adult');
} else {
  console.log('Minor');
}
```

上面的代码判断 `age` 是否大于等于 18，输出 `'Adult'` 或 `'Minor'`。

#### 1.4 `for`

`for` 循环用于多次执行一段代码，通常用于遍历数组或重复执行任务。

示例：

```javascript
let numbers = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers.length; i++) {
  console.log(numbers[i]); // 输出 1, 2, 3, 4, 5
}
```

### 2. 嵌入 HTML

#### 2.1 `<div>{{arg}}</div>`

在 HTML 中，`<div>` 是一个常用的标签，用于包裹其他内容。`{{arg}}` 通常出现在 Vue.js 或类似框架中，用来表示绑定的动态数据。

示例（Vue.js）：

```html
<div>{{ message }}</div>
```

假设 `message = 'Hello'`，则页面显示 `Hello`。

#### 2.2 写在 `<script>` 中

JavaScript 代码通常写在 `<script>` 标签内，放在 HTML 文档中。它可以位于 `<head>` 或 `<body>` 中。

示例：

```html
<!DOCTYPE html>
<html>
  <head>
    <script>
      let greeting = 'Hello, World!';
      console.log(greeting); // 控制台输出 'Hello, World!'
    </script>
  </head>
  <body>
    <div>{{ greeting }}</div>
  </body>
</html>
```

# *Vue*

> [!info] powered by Kimi

> [!summary]- 提示词填充
> 章节：Vue
> 
> 本章目录：事件监听、动态绑定、双向绑定、侦听器、列表渲染、条件渲染、组件的注册和使用、父子组件的相互通讯。
> 
> key words:
> ref, const str = ref("")
> .value, console.log(x.value)
> @click
> @mouseenter
> @mouseleave
> 双向绑定：v-model="x" in 输入框
> 动态绑定  class 前面+：后面写公式/变量名，img src -> img :src
> 常用,    :class="\[str?'completed':'item']"
> v-for, {{ }}
> v-for="(item, index) in list"
> 侦听器 watch(str, add),str 变化，就执行函数 add
> function logger(a1, a2){
>   console.log("new = "+a1+"old = "+a2)
> }
> watch(value,logger)
> 
> 深度监听：watch(value, logger, {deep:true})
> 
> v-show="true/false"
> 
> v-if
> 组件
> 组件传值，defineprops & defineemits

### 安装

首先下载、安装 nvm

然后在命令行中：

```bash
nvm install 20
nvm ls
```

列出最新环境，假如说是 `20.13.1`，则输入：

```bash
nvm use 20.13.1
```

检测是否安装成功：

```bash
node -v
npm -v
```

输出版本号即为安装成功。

### 定义变量 || `const value = ref('');`

使用 以下操作来定义变量。

``` javascript
const hello_str = ref('hello world')
const number_100 = ref(100)
const list = ref([
  { value: '吃饭', isCompleted: true },
  { value: '睡觉', isCompleted: false },
  { value: '打豆豆', isCompleted: false }
])
```

### 事件监听 ||  `@[movement]="[function name]"`

*注：事件监听是我亲自动手，亲自扣字，亲自修改，给出的一个例子。*
事件监听的作用是：当用户对页面上的某个东西（比如按钮）做了某个动作（比如点击）时，就会自动执行一段代码（比如一个函数）。简单来说，就是“用户做了什么动作，页面就做出什么反应”。
在 Vue.js 中，事件监听是通过在标签上加一个 `@` 符号来实现的。
具体样例如下：

```vue
<div @click="add" class="button">Click me to call function add.</div>
```

*注：上面的 `button` 是我们假想出来的一个类，假设这个 `button` 类已经在 `<style>` 里面写好了，它就是一个按钮样式。*
**运行效果：**
当用户点击这个按钮时，页面就会调用 `add` 函数。
如果 `add` 函数的作用是增加一个数字，那么每次点击按钮，数字就会增加。

除了点击事件`@click`，还有其他事件可以用来监听用户的操作：

- **`@mouseenter`**：当鼠标移入按钮时触发。
- **`@mouseleave`**：当鼠标移出按钮时触发。

以下内容交给 kimi:

---

### 动态绑定 || `:[attribute]="[expression]"`

**动态绑定**的作用是：让页面上的元素（比如图片的地址、类名等）根据变量的值动态变化。简单来说，就是“变量变了，页面上的元素也会跟着变”。

在 Vue.js 中，动态绑定是通过在属性前加一个 `:` 符号来实现的。比如绑定图片地址：

```html
<img :src="imageUrl">
```

注：`imageUrl` 是一个变量，它的值可以是图片的路径。

运行效果：

- 如果 `imageUrl` 的值是 `"https://example.com/image1.jpg"`，那么页面上就会显示这张图片。
- 如果变量的值变了，图片也会跟着变。

除了图片地址，还可以动态绑定类名：

```html
<div :class="[isCompleted ? 'completed' : 'item']">Item</div>
```

注：`isCompleted` 是一个布尔值变量，`completed` 和 `item` 是两个不同的样式类。

运行效果：

- 如果 `isCompleted` 是 `true`，这个 `div` 的类名就会是 `completed`，页面上的样式会根据 `completed` 类的样式显示。
- 如果是 `false`，就会应用 `item` 类的样式。

---

### 双向绑定 || `v-model="[variable]"`

**双向绑定**的作用是：让页面上的输入框和 JavaScript 数据保持同步。简单来说，就是“输入框的值变了，变量也会变；变量变了，输入框的值也会跟着变”。

在 Vue.js 中，双向绑定是通过 `v-model` 实现的。比如：

```html
<input v-model="todoValue" type="text" placeholder="Enter a todo">
```

注：`todoValue` 是一个变量。

运行效果：

- 当用户在输入框中输入内容时，`todoValue` 的值会自动更新为输入的内容。
- 如果代码中修改了 `todoValue` 的值，输入框的内容也会自动更新。

---

### 列表渲染 || `v-for="(item, index) in [list]"`

**列表渲染**的作用是：根据数组中的数据，动态生成一组 HTML 元素。简单来说，就是“数组里有多少个对象，页面上就会显示多少个对应的元素”。

在 Vue.js 中，列表渲染是通过 `v-for` 实现的。比如：

```html
<div v-for="(item, index) in list" :key="index">
  <span>{{ item.value }}</span>
</div>
```

注：`list` 是一个数组，`item` 是数组中的每个对象，`index` 是对象的索引。

运行效果：

- 如果 `list` 的值是 `[{"value": "吃饭"}, {"value": "睡觉"}]`，页面上就会显示两个 `div`，分别包含“吃饭”和“睡觉”。
- 如果数组的值变了，页面上的内容也会跟着变。

在 Vue.js 中，列表渲染是通过 `v-for` 实现的。例如：

```html
<div v-for="(item, index) in list" :class="[item.isCompleted ? 'completed' : 'item']">
  <div>
    <input v-model="item.isCompleted" type="checkbox" />
    <span class="name">{{ item.value }}</span>
  </div>
  <div @click="del(index)" class="del">del</div>
</div>
```

**运行效果：**

- 根据 `list` 数组中的每一项数据，生成一个任务项。
- 如果 `item.isCompleted` 为 `true`，则任务项会被标记为完成状态。

![](/assets/images/Pasted image 20250227130955.png)

---

### 条件渲染 || `v-if / v-show`

**条件渲染**的作用是：根据变量的值决定是否显示某个元素。简单来说，就是“变量为真，显示元素；变量为假，不显示元素”。

在 Vue.js 中，条件渲染可以通过 `v-if` 和 `v-show` 实现：

```html
<div v-if="isVisible">This will only show if isVisible is true.</div>
<div v-show="isHidden">This will show or hide based on isHidden.</div>
```

注：`isVisible` 和 `isHidden` 是布尔值变量。

运行效果：

- 如果 `isVisible` 是 `true`，第一个 `div` 会显示；如果是 `false`，则不会显示。
- `v-show` 和 `v-if` 的区别是：`v-show` 只是控制元素的显示和隐藏，而 `v-if` 是直接决定是否渲染元素。

---

### 侦听器 || `watch(variable, callback)`

**侦听器**的作用是：当某个变量的值发生变化时，自动执行一个函数。简单来说，就是“变量变了，函数就会自动执行”。

在 Vue.js 中，侦听器是通过 `watch` 实现的。有两种常见的写法：

#### 写法一：匿名函数作为第二个参数

```javascript
const value = ref('');
watch(value, (newVal, oldVal) => {
  console.log(`New value: ${newVal}, Old value: ${oldVal}`);
});
```

运行效果：  
当 `value` 的值从 `"old"` 变为 `"new"` 时，控制台会输出：`New value: new, Old value: old`。

#### 写法二：函数名称作为第二个参数

你还可以定义一个单独的函数，然后将函数名称作为 `watch` 的第二个参数。比如：

```javascript
const value = ref('');

function logger(newVal, oldVal) {
  console.log(`New value: ${newVal}, Old value: ${oldVal}`);
}

watch(value, logger);
```

运行效果：  
当 `value` 的值发生变化时，`logger` 函数会被调用，并打印新值和旧值。

#### 深度监听

如果需要监听一个对象或数组的内部变化，可以使用深度监听：

```javascript
const obj = ref({ name: 'Kimi', age: 25 });

function logChanges(newVal, oldVal) {
  console.log(`New value:`, newVal);
  console.log(`Old value:`, oldVal);
}

watch(obj, logChanges, { deep: true });
```

运行效果：  
如果 `obj` 的某个属性（比如 `name` 或 `age`）发生变化，`logChanges` 函数会被调用。

---

### 组件的注册和使用

**组件**的作用是：把页面分成一个个小的部分，每个部分可以单独开发和复用。简单来说，就是“把复杂的页面拆成小块，方便开发和管理”。

在 Vue.js 中，组件可以通过 `<script setup>` 和 `import` 来注册和使用。比如：

```javascript
import myButton from './components/button.vue';
```

这时，`button.vue` 中的内容是：

```vue
<!-- button.vue -->
<script setup>
import { defineProps } from 'vue';

const props = defineProps(['text'])
</script>

<template>
    <div class="button">{{props.text}}</div>
</template>

<style scoped>
.button{
    margin: 100px 0 0 200px;
    width: 100px;
    height: 50px;
    line-height: 50px;
    text-align: center;
    background-color: antiquewhite;
    border-radius: 10px;
}
</style>

```

然后在模板中使用：

```html
<myButton text="Click me"></myButton>
```

注：`myButton` 是一个组件，`text` 是传递给组件的属性。即使 `button.vue` 中的组件名字叫 `button`，也不影响父组件给它重命名。

运行效果：

- 页面上会显示一个按钮，按钮的内容是“Click me”。

---

### 父子组件的相互通讯

这个也是我亲自写的，改 Bug+画图类似我了，AI 不会干这些事情

**父子组件的相互通讯**的作用是：让父组件可以向子组件传递数据，子组件也可以向父组件发送消息。简单来说，就是“父组件告诉子组件怎么做，子组件也可以告诉父组件发生了什么”。

在 Vue.js 中，父子组件通讯可以通过 `defineProps` 和 `defineEmits` 实现。

#### 父传子 || `子defineProps(["arg"]), 父div<arg=value>`

**父组件：**

```html
<myButton text="akari"></myButton>
```

**子组件：**
在 `scripts` 中：

```javascript
import { defineProps, defineEmits } from 'vue';
const props = defineProps(['text']);
```

在 `template` 中：

```html
<div class="button">{{props.text}}</div>
```

效果如下。

![](/assets/images/Pasted image 20250227151842.png)

#### 子传父 || `子defineEmits(["arg"]), 父@arg=func`

子组件：

```vue
<script setup>
import { defineProps, defineEmits, ref } from 'vue';
const props = defineProps(['text'])
const emit = defineEmits(["ok"])
const hello_str = ref("hello world!")
function send(){
    // suppose that here we have some
    // data processing steps.
    emit('ok', hello_str)
</script>


<template>
    <div @click="send" class="button">{{props.text}}</div>
</template>
}
```

父组件：

```vue
<script setup>
import myButton from './components/button.vue'
function PrintTest(str){
  console.log(str.value)
}
</script>

<template>
	<myButton @ok="PrintTest" text="akari"></myButton>
</template>
```

![](/assets/images/Pasted image 20250227160018.png)

效果：

![](/assets/images/Pasted image 20250227160122.png)

# *Axios*

Axios 是一个**从前端向后端发送（POST），或请求（GET）** 内容的桥梁。

提一嘴，前面我们学习的 HTML, CSS, JavaScript, Vue, 都是前端开发的工具。

安装

```bash
npm install axios
```

调用

```javascript
import axios from 'axios'
```

前端到后端的数据传输，通常用到一个 url，比如：

```
url:"https://q6zv39.laf.run/get_list"
```

打开这个 url，可以看到其中的内容：

![](/assets/images/Pasted image 20250227191011.png)

这就是后端给我们发过来的数据，（现在）作为前端，我们要对其进行处理，比如就用这个数据，来替换我们的 todo-list 吧！

### GET request

```vue
<script setup>

import { ref } from 'vue'
import axios from 'axios'

const list = ref([])
async function getList(){
  const res = await axios({
    url:"https://q6zv39.laf.run/get_list", // 请求的 URL
    method:"GET"  						   // 请求方法，这里是 GET 请求
  })

  list.value = res.data.list
  console.log(res)
}
</script>

```

`async` 是 JavaScript 中的一个关键字，用于声明一个函数是异步的。异步函数的主要特点是它允许在函数内部使用 `await` 关键字，从而暂停函数的执行，直到某个异步操作完成。*这使得异步代码的逻辑看起来像同步代码，更易于理解和维护。*

- **语法**：

  ```javascript
  async function functionName() {
      // 函数体
  }
  ```

***为什么使用异步函数？***
- *在前端开发中，网络请求是一种常见的异步操作。使用 `async` 和 `await` 可以让异步代码的逻辑更加清晰，避免回调地狱（callback hell）。*

**响应对象 `res` 的结构**：
  `axios` 返回的响应对象 `res` 包含以下属性：
  - `res.data`：服务器返回的数据，通常是 JSON 格式。
  - `res.status`：HTTP 状态码（如 200 表示成功，404 表示未找到等）。
  - `res.headers`：响应头信息。
  - *`res.config`：请求的配置信息。*
  - *`res.request`：底层的请求对象（如 XMLHttpRequest）。*

最后强调一点。`axios` 是小括号在外，里面还有个大括号。

### POST request

```javascript
async function del(id){
  await axios({
    url:'https://q6zv39.laf.run/del_todo',
    method:'POST',
    data:{
      id: id
    }
  })
  
  getList()
}
```

其中，`data` 字段传的是前端向后端的返回值。

# *Mongo*

> [!info] powered by kimi

> [!summary]- 提示词填充
> 章节：Node + Mongo 
> 本章目录：数据库调用方法、更改数据库里的元素、数据检验、sealos cloud 运行方法
> 
> key words:
> 函数（代码）与集合（数据库）
> db
> cloud.mongo.db
> ctx
> ctx.body
> 	return 结构体 传给前端
> db.collection,insertOne,findOne,updateOne,deleteOne 及它们的返回值, await
> 验证数据结构是否合法
> typeof body !== 'object'
> new ObjectId
> 
> 发布、接口调试方法
> \*我往里掺了点别的

嗨嗨，这里是永雏塔菲喵～今天咱们来搞学习，主题是 Node + Mongo，听起来是不是有点复杂？别怕，跟着塔菲一起，咱们慢慢来，保证让你轻松掌握喵～准备好了吗？那咱们开始咯～

### 数据库调用方法

**函数（代码）与集合（数据库）**  
在 Node + Mongo 里，函数是用来操作数据库集合的工具喵。就像我们用一个神奇的小铲子去挖宝（数据库里的数据）一样，函数就是那个小铲子，而集合就是装宝物的大箱子（数据库里的数据集合）。  
**Example**  

```javascript
import cloud from '@lafjs/cloud';

export default async function (ctx: FunctionContext) {
  // 这里可以写调用数据库的函数喵
}
```

上面这段代码就像是打开数据库大门的钥匙，虽然还没具体操作啥，但已经准备好要和数据库“交流”啦。

**db**  
`db` 就像是数据库的“管家”，它管理着各种集合（数据库里的表）。我们通过 `db` 来找到我们需要操作的集合喵。  
**Example**  

```javascript
const db = cloud.mongo.db;
```

这行代码就是把数据库的“管家”请出来，方便我们后面找集合用喵。

**db.collection**  
`db.collection` 是用来指定我们要操作哪个集合（表）的，就像我们告诉管家“我要去哪个房间找东西”一样喵。  
**Example**  

```javascript
const collection = db.collection('collectionName');
```

这里就是告诉管家“我要去叫 collectionName 的房间找东西”喵。

**insertOne, findOne, updateOne, deleteOne 及它们的返回值**  
这些函数就像是数据库操作的“四大天王”喵：  
- `insertOne`：往集合里插入一个新元素，就像往宝箱里放一个新的宝物喵。  
- `findOne`：从集合里找一个符合条件的元素，就像在宝箱里找一个特定的宝物喵。  
- `updateOne`：更新集合里一个符合条件的元素，就像把宝箱里的一个宝物换了个样子喵。  
- `deleteOne`：从集合里删除一个符合条件的元素，就像把宝箱里的一个宝物拿走喵。  
它们的返回值就像是操作后的“反馈”，告诉我们操作成功没成功，或者返回了什么结果喵。  
**Example 1.  `insertOne`**  

```javascript
const result = await collection.insertOne({ name: 'taffy', age: 18 });
console.log(result); // 这里会输出插入操作的结果喵
```

这段代码就是往集合里插入了一个叫 taffy 的宝物，然后看看操作结果喵。

**Example 2. `updateOne`**
前面提到过 `updateOne` 是用来更新集合里的元素的喵。就像我们发现宝箱里的宝物有点旧了，想给它换个新样子喵。  

```javascript
const result = await collection.updateOne({ name: 'taffy' }, { $set: { age: 19 } });
console.log(result); // 这里会输出更新操作的结果喵
```

这段代码就是把叫 taffy 的宝物的年龄从 18 改成了 19 喵。

**await**  
`await` 就像是让我们“等一等”的魔法，因为数据库操作可能需要一点时间，所以我们得等它完成才能继续后面的操作喵。  
**Example**  

```javascript
const result = await collection.findOne({ name: 'taffy' });
console.log(result); // 这里会输出找到的宝物喵
```

这里就是等 `findOne` 找到宝物后再继续喵。

### 数据检验

**验证数据结构是否合法**  
在操作数据库之前，我们要检查一下数据的结构是不是合法的，不然可能会出错喵。就像我们往宝箱里放宝物之前，要检查一下宝物是不是完整的喵。  
`typeof body !== 'object'
这行代码是用来检查 `body` 是不是对象的，如果不是对象，那可能就不合法了喵。  
**Example**  

```javascript
if (typeof ctx.body !== 'object') {
  ctx.body = { error: 'Invalid data structure' };
  return;
}
```

这里就是检查 `ctx.body` 是不是对象，如果不是，就返回一个错误信息喵。

**new ObjectId**  
`new ObjectId` 是用来生成一个唯一的标识符的，就像给每个宝物贴上一个独一无二的标签喵。  
**Example**  

```javascript
const objectId = new ObjectId();
console.log(objectId); // 这里会输出一个独一无二的标识符喵
```

这段代码就是生成了一个独一无二的标签喵。

### sealos cloud 运行方法

**cloud.mongo.db**  
`cloud.mongo.db` 就是连接到数据库的“桥梁”，让我们能在 sealos cloud 上操作数据库喵。  
**Example**  

```javascript
const db = cloud.mongo.db;
```

这行代码就是搭建好了连接数据库的桥梁喵。

**ctx**  
`ctx` 就像是传递信息的“小信使”，它会把前端传来的信息带给我们，也会把我们的结果带给前端喵。  
**ctx.body**  
`ctx.body` 是用来传递具体的数据的，就像小信使手里拿着的信封，里面装着要传递的信息喵。  
**Example**  

```javascript
ctx.body = { message: 'Operation successful' };
```

这行代码就是让小信使把“操作成功”的信息带给前端喵。

**return 结构体 传给前端**  
我们操作完数据库后，要把结果打包成一个结构体（对象），然后通过 `ctx.body` 传给前端喵。就像我们把宝物装进一个漂亮的盒子里，让小信使带给别人喵。  
**Example**  

```javascript
ctx.body = { result: 'Data updated', data: updatedData };
```

这里就是把更新后的数据和结果信息打包好，让小信使带给前端喵。

### 发布、接口调试方法

发布和接口调试就像是检查我们的“作品”是不是能正常工作喵。我们可以用一些工具来测试接口，比如 Postman，看看能不能得到正确的结果喵。如果发现有问题，就再检查一下代码，就像检查宝物是不是有瑕疵一样喵。

---

喵～以上就是按照你给的本章目录和 key words list 写的笔记啦，希望对你有帮助喵～如果有啥不懂的地方，随时问我哦喵～（感觉我这笔记写得还挺顺的，应该没啥问题喵～）
